// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import {ERC721, IERC721, Context} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";
import {Counters} from "@openzeppelin/contracts/utils/Counters.sol";
import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";
import {ERC2771Context} from "@openzeppelin/contracts/metatx/ERC2771Context.sol";
import {ISBT} from "../../interface/token/ISBT.sol";
import {IPJManager} from "../../interface/pjmanager/IPJManager.sol";

contract SBT is ISBT, ERC721, AccessControl, ERC2771Context {
  using Counters for Counters.Counter;
  using Strings for uint256;

  bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
  bytes32 public constant URIUPDATER_ROLE = keccak256("URIUPDATER_ROLE");
  bytes32 public constant BURNER_ROLE = keccak256("BUNER_ROLE");

  bool public isTransfable = false;
  IPJManager public immutable pjManager;
  string private _baseTokenURI;
  address[] private _boardingMembers;
  mapping(address => bool) private _isBoardingMember;
  Counters.Counter private _tokenIdTracker;

  /**
   * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE`, `URIUPDATETR_ROLE` and
   * `BURNER_ROLE` to the account that deploys the contract.
   *
   * Token URIs will be autogenerated based on `baseURI` and their token IDs.
   * See {ERC721-tokenURI}.
   */
  constructor(
    string memory _name,
    string memory _symbol,
    string memory baseTokenURI,
    IPJManager _pjManager,
    address _admin,
    address _trustedForwarder
  ) ERC721(_name, _symbol) ERC2771Context(_trustedForwarder) {
    _baseTokenURI = baseTokenURI;
    pjManager = _pjManager;
    _tokenIdTracker.increment();

    _setupRole(DEFAULT_ADMIN_ROLE, _admin);
    _setupRole(MINTER_ROLE, _admin);
    _setupRole(URIUPDATER_ROLE, _admin);
    _setupRole(BURNER_ROLE, _admin);
  }

  /**
   * @dev Resolve metadata from Questry Protocol DID for the board which tokenId is `tokenId`.
   * Example: https://example.kaname.io/did:kaname:
   * DID spec: https://github.com/KanameProtocol/did-kaname-spec
   * See {IERC721Metadata-tokenURI}
   */
  function tokenURI(uint256 tokenId)
    public
    view
    virtual
    override(ERC721)
    returns (string memory)
  {
    require(
      _exists(tokenId),
      "ERC721Metadata: URI query for nonexistent token"
    );
    return string(abi.encodePacked(_baseURI(), did(tokenId)));
  }

  /**
   * @dev Return the _baseTokenURI.
   * See {ERC721-_baseURI}.
   */
  function _baseURI()
    internal
    view
    virtual
    override(ERC721)
    returns (string memory)
  {
    return _baseTokenURI;
  }

  /**
   * @dev Update baseTokenURI to `_uri`.
   */
  function updateBaseTokenURI(string memory _uri) external {
    require(
      hasRole(URIUPDATER_ROLE, _msgSender()),
      "SBT: must have URI updater role to update URI"
    );
    _baseTokenURI = _uri;
  }

  /**
   * @dev Resolve Questry Protocol DID from the board which tokenId is `tokenId`.
   */
  function did(uint256 tokenId) public view returns (string memory) {
    address member = ownerOf(tokenId);
    string memory boardId = pjManager
      .resolveBoardId(address(this), tokenId)
      .toString();
    return
      string(
        abi.encodePacked(
          didSchema(),
          ":",
          didNamespace(),
          ":",
          didMember(member),
          ":",
          boardId
        )
      );
  }

  /**
   * @dev Returns Questry Protocol DID spec's schema.
   */
  function didSchema() public pure returns (string memory) {
    return "did:questry";
  }

  /**
   * @dev Returns Questry Protocol DID spec's namespace corresponding to the boards.
   */
  function didNamespace() public view returns (string memory) {
    string memory chainId = block.chainid.toString();
    string memory hexPJManager = Strings.toHexString(
      uint160(address(pjManager)),
      20
    );
    return string(abi.encodePacked("eip155:", chainId, ":", hexPJManager));
  }

  /**
   * @dev Returns Questry Protocol DID spec's member.
   */
  function didMember(address member) public view returns (string memory) {
    string memory chainId = block.chainid.toString();
    string memory hexMember = Strings.toHexString(uint160(member), 20);
    return string(abi.encodePacked("eip155:", chainId, ":", hexMember));
  }

  /// @inheritdoc ISBT
  function mint(address to) public {
    require(
      hasRole(MINTER_ROLE, _msgSender()),
      "SBT: must have minter role to mint"
    );

    if (!_isBoardingMember[to]) {
      _boardingMembers.push(to);
      _isBoardingMember[to] = true;
    }

    uint256 tokenId = _tokenIdTracker.current();
    _mint(to, tokenId);
    _tokenIdTracker.increment();

    IPJManager(pjManager).registerBoard(address(this), tokenId);
  }

  /// @inheritdoc ISBT
  function bulkMint(address[] calldata tos) public {
    for (uint256 i = 0; i < tos.length; i++) {
      mint(tos[i]);
    }
  }

  /// @inheritdoc ISBT
  function burn(uint256 tokenId) public {
    require(
      hasRole(BURNER_ROLE, _msgSender()),
      "SBT: must have burner role to burn"
    );

    address owner = ownerOf(tokenId);
    if (balanceOf(owner) == 1) {
      _isBoardingMember[owner] = false;
      // XXX: too much gas cost especially when tokens bulk burned
      uint256 newIdx = 0;
      for (uint256 i = 0; i < _boardingMembers.length; i++) {
        if (_boardingMembers[i] != owner) {
          _boardingMembers[newIdx++] = _boardingMembers[i];
        }
      }
      require (newIdx + 1 == _boardingMembers.length, "SBT: cannot remove boarding member");
      _boardingMembers.pop();
    }

    _burn(tokenId);
  }

  /// @inheritdoc ISBT
  function bulkBurn(uint256[] calldata tokenIds) public {
    for (uint256 i = 0; i < tokenIds.length; i++) {
      burn(tokenIds[i]);
    }
  }

  /// @inheritdoc ISBT
  function boardingMembers() external view returns (address[] memory) {
    return _boardingMembers;
  }

  /// @inheritdoc ISBT
  function boardingMembersExist() external view returns (bool) {
    return _boardingMembers.length > 0;
  }

  /**
   * @dev Returns if `account` has the token, in other words, it is a boarding member.
   * Note that only one token can be minted from the same SBT contract per account.
   */
  function isBoardingMember(address account) external view returns (bool) {
    return _isBoardingMember[account];
  }

  /// @dev Overridden for SBT
  function _transfer(
    address from,
    address to,
    uint256 tokenId
  ) internal virtual override {
    require(isTransfable, "SBT: Err Token is SBT");
    super._transfer(from, to, tokenId);
  }

  /// @dev Overridden for SBT
  function _setApprovalForAll(
    address owner,
    address operator,
    bool approved
  ) internal virtual override {
    require(isTransfable, "SBT: Err Token is SBT");
    super._setApprovalForAll(owner, operator, approved);
  }

  /// @dev Overridden for SBT
  function _approve(address to, uint256 tokenId) internal virtual override {
    require(isTransfable || to == address(0), "SBT: Err Token is SBT");
    super._approve(to, tokenId);
  }

  /**
   * @dev See {ERC2771Context-_msgData}
   */
  function _msgData()
    internal
    view
    override(ERC2771Context, Context)
    returns (bytes calldata)
  {
    return ERC2771Context._msgData();
  }

  /**
   * @dev See {ERC2771Context-_msgSender}
   */
  function _msgSender()
    internal
    view
    override(ERC2771Context, Context)
    returns (address sender)
  {
    return ERC2771Context._msgSender();
  }

  /**
   * @dev See {IERC165-supportsInterface}.
   *
   * - Contracts can inherit from multiple parent contracts.
   *   When a function is called that is defined multiple times in
   *   different contracts, parent contracts are searched from
   *   right to left, and in depth-first manner.
   *
   * - BasicERC721.supportsInterface() returns ERC721.supportsInterface();
   */
  function supportsInterface(bytes4 interfaceId)
    public
    view
    virtual
    override(AccessControl, ERC721)
    returns (bool)
  {
    return super.supportsInterface(interfaceId);
  }
}
